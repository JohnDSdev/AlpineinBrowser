<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Alpine Browser VM (Offline)</title>
  <style>
    :root {
      --bg: #f6f3ed;
      --ink: #1f2933;
      --muted: #66717d;
      --card: #fffdf9;
      --line: #d6d0c4;
      --accent: #0d6b4d;
      --accent-2: #e7f4ed;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      color: var(--ink);
      background:
        radial-gradient(circle at 20% -10%, #fffaf1 0%, transparent 45%),
        radial-gradient(circle at 100% 0%, #dff2e8 0%, transparent 55%),
        var(--bg);
      font-family: "Source Sans 3", "Trebuchet MS", Verdana, sans-serif;
    }

    .wrap {
      max-width: 1140px;
      margin: 0 auto;
      padding: 18px;
    }

    h1 {
      margin: 0;
      font-size: 2rem;
      letter-spacing: 0.02em;
    }

    .subtitle {
      margin: 8px 0 16px;
      color: var(--muted);
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 12px;
    }

    .toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: var(--card);
      font-size: 0.95rem;
    }

    .toolbar input[type="url"] {
      min-width: 250px;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      background: var(--card);
      color: var(--ink);
    }

    button {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: var(--card);
      padding: 10px 14px;
      cursor: pointer;
      font-weight: 600;
      color: var(--ink);
    }

    button.primary {
      background: var(--accent);
      color: #ffffff;
      border-color: #0a523b;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .status {
      padding: 9px 12px;
      border: 1px solid var(--line);
      border-radius: 999px;
      background: var(--accent-2);
      color: #0f513a;
      font-size: 0.95rem;
    }

    .grid {
      display: grid;
      grid-template-columns: 1.45fr 0.9fr;
      gap: 12px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 5px 24px rgba(39, 34, 24, 0.08);
    }

    .head {
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      background: #fff9ef;
      font-weight: 600;
    }

    .body {
      padding: 12px;
    }

    #screen {
      width: 100%;
      aspect-ratio: 4 / 3;
      min-height: 360px;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #222;
    }

    #screen canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
      image-rendering: pixelated;
    }

    #serial {
      height: 420px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
      background: #0c1117;
      color: #dde4ed;
      border: 1px solid #243040;
      border-radius: 8px;
      padding: 10px;
      font-family: "Cascadia Mono", "Consolas", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.3;
    }

    #log {
      height: 170px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: "Cascadia Mono", "Consolas", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.3;
      color: #203040;
      background: #f4efe3;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 10px;
    }

    .tip {
      margin: 0 0 10px;
      color: var(--muted);
      font-size: 0.94rem;
      line-height: 1.35;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }

      #screen {
        min-height: 300px;
      }
    }
  </style>
  <script src="assets/js/libv86.js"></script>
  <script src="assets/js/vm-assets.js"></script>
</head>
<body>
  <main class="wrap">
    <h1>Alpine Linux in One HTML File</h1>
    <p class="subtitle">Open this file and boot locally. Optional network relay, persistent state, and backup restore are built in.</p>

    <div class="toolbar">
      <button id="start" class="primary">Start Alpine VM</button>
      <button id="restart" disabled>Restart VM</button>
      <button id="save" disabled>Save State</button>
      <button id="export" disabled>Export Data</button>
      <button id="import">Import Data</button>
      <button id="clear">Clear Saved Data</button>
      <label><input type="checkbox" id="netToggle" checked> Network</label>
      <input id="relayUrl" type="url" value="wss://relay.widgetry.org/" spellcheck="false">
      <input id="importFile" type="file" accept=".bin,.v86state,application/octet-stream" hidden>
      <span class="status" id="status">Idle</span>
    </div>

    <div class="grid">
      <section class="card">
        <div class="head">
          <span>VGA Console</span>
          <span>Click inside to focus</span>
        </div>
        <div class="body">
          <p class="tip">Use this panel for normal Alpine interaction. Login is usually <code>root</code> (no password).</p>
          <div id="screen"></div>
        </div>
      </section>

      <section class="card">
        <div class="head">
          <span>Serial Output</span>
          <span>Read-only mirror</span>
        </div>
        <div class="body">
          <div id="serial"></div>
        </div>
      </section>

      <section class="card" style="grid-column: 1 / -1;">
        <div class="head">
          <span>Boot Log</span>
          <span>Troubleshooting</span>
        </div>
        <div class="body">
          <div id="log"></div>
        </div>
      </section>
    </div>
  </main>

  <script>
    const CONFIG = {
      memory_size: 512 * 1024 * 1024,
      vga_memory_size: 8 * 1024 * 1024,
      disable_speaker: true,
      autostart: true
    };

    const startButton = document.getElementById("start");
    const restartButton = document.getElementById("restart");
    const saveButton = document.getElementById("save");
    const exportButton = document.getElementById("export");
    const importButton = document.getElementById("import");
    const clearButton = document.getElementById("clear");
    const netToggle = document.getElementById("netToggle");
    const relayUrlInput = document.getElementById("relayUrl");
    const importFileInput = document.getElementById("importFile");
    const statusEl = document.getElementById("status");
    const screenEl = document.getElementById("screen");
    const serialEl = document.getElementById("serial");
    const logEl = document.getElementById("log");

    let vm = null;
    let decodedAssets = null;
    let autoSaveTimer = null;
    let saveInProgress = false;
    let loadedStateForBoot = null;
    let loadedStateSource = null;
    let persistentDisk = null;

    const DB_NAME = "alpine-browser-vm";
    const STORE_NAME = "state";
    const DISK_STORE_NAME = "disk_chunks";
    const STATE_KEY = "snapshot";
    const META_KEY = "meta";
    const DISK_META_KEY = "disk_meta";
    const FILE_MAGIC = -2039052682;
    const FILE_VERSION = 6;
    const AUTO_SAVE_MS = 45000;
    const DISK_CHUNK_SIZE = 64 * 1024;
    const DISK_SIZE_BYTES = 1024 * 1024 * 1024;

    function formatBytes(bytes) {
      if (!bytes || bytes < 1024) {
        return String(bytes || 0) + " B";
      }
      const units = ["KB", "MB", "GB"];
      let value = bytes / 1024;
      let unitIndex = 0;
      while (value >= 1024 && unitIndex < units.length - 1) {
        value /= 1024;
        unitIndex += 1;
      }
      return value.toFixed(2) + " " + units[unitIndex];
    }

    function isLikelyV86State(buffer) {
      if (!(buffer instanceof ArrayBuffer) || buffer.byteLength < 16) {
        return false;
      }
      const view = new Int32Array(buffer, 0, 4);
      return view[0] === FILE_MAGIC && view[1] === FILE_VERSION;
    }

    function openDb() {
      return new Promise(function(resolve, reject) {
        if (!("indexedDB" in window)) {
          reject(new Error("IndexedDB is not available in this browser."));
          return;
        }
        const request = indexedDB.open(DB_NAME, 2);
        request.onupgradeneeded = function() {
          const db = request.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME);
          }
          if (!db.objectStoreNames.contains(DISK_STORE_NAME)) {
            db.createObjectStore(DISK_STORE_NAME);
          }
        };
        request.onsuccess = function() {
          resolve(request.result);
        };
        request.onerror = function() {
          reject(request.error || new Error("Failed to open IndexedDB."));
        };
      });
    }

    async function idbGet(key, storeName) {
      const targetStore = storeName || STORE_NAME;
      const db = await openDb();
      return new Promise(function(resolve, reject) {
        const tx = db.transaction(targetStore, "readonly");
        const store = tx.objectStore(targetStore);
        const request = store.get(key);
        request.onsuccess = function() { resolve(request.result || null); };
        request.onerror = function() { reject(request.error || new Error("IndexedDB read failed.")); };
      }).finally(function() {
        db.close();
      });
    }

    async function idbPut(key, value, storeName) {
      const targetStore = storeName || STORE_NAME;
      const db = await openDb();
      return new Promise(function(resolve, reject) {
        const tx = db.transaction(targetStore, "readwrite");
        const store = tx.objectStore(targetStore);
        const request = store.put(value, key);
        request.onsuccess = function() { resolve(); };
        request.onerror = function() { reject(request.error || new Error("IndexedDB write failed.")); };
      }).finally(function() {
        db.close();
      });
    }

    async function idbDelete(keys, storeName) {
      const targetStore = storeName || STORE_NAME;
      const db = await openDb();
      return new Promise(function(resolve, reject) {
        const tx = db.transaction(targetStore, "readwrite");
        const store = tx.objectStore(targetStore);
        for (const key of keys) {
          store.delete(key);
        }
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function() { reject(tx.error || new Error("IndexedDB delete failed.")); };
      }).finally(function() {
        db.close();
      });
    }

    async function idbPutMany(entries, storeName) {
      const targetStore = storeName || STORE_NAME;
      const db = await openDb();
      return new Promise(function(resolve, reject) {
        const tx = db.transaction(targetStore, "readwrite");
        const store = tx.objectStore(targetStore);
        for (const entry of entries) {
          store.put(entry.value, entry.key);
        }
        tx.oncomplete = function() { resolve(); };
        tx.onerror = function() { reject(tx.error || new Error("IndexedDB batch write failed.")); };
      }).finally(function() {
        db.close();
      });
    }

    class IndexedDbDiskBuffer {
      constructor(byteLength, chunkSize) {
        this.byteLength = byteLength;
        this.chunkSize = chunkSize;
        this.onprogress = null;
        this.onload = null;
        this.cache = new Map();
        this.dirty = new Set();
        this.flushTimer = null;
        this.flushing = false;
      }

      chunkKey(index) {
        return "chunk:" + index;
      }

      async load() {
        const meta = await idbGet(DISK_META_KEY);
        if (!meta) {
          await idbPut(DISK_META_KEY, {
            byteLength: this.byteLength,
            chunkSize: this.chunkSize,
            createdAt: Date.now()
          });
        } else if (meta.byteLength !== this.byteLength || meta.chunkSize !== this.chunkSize) {
          throw new Error("Saved disk format mismatch. Clear Saved Data to recreate disk.");
        }
        if (this.onload) {
          this.onload({ loaded: this.byteLength, total: this.byteLength, lengthComputable: true });
        }
      }

      async readChunk(index) {
        if (this.cache.has(index)) {
          return this.cache.get(index);
        }
        const existing = await idbGet(this.chunkKey(index), DISK_STORE_NAME);
        let chunk = null;
        if (existing instanceof Uint8Array) {
          chunk = existing;
        } else if (existing instanceof ArrayBuffer) {
          chunk = new Uint8Array(existing);
        }
        if (!chunk || chunk.byteLength !== this.chunkSize) {
          chunk = new Uint8Array(this.chunkSize);
        }
        this.cache.set(index, chunk);
        return chunk;
      }

      scheduleFlush() {
        if (this.flushTimer) {
          return;
        }
        this.flushTimer = setTimeout(() => {
          this.flushTimer = null;
          this.flushNow();
        }, 1500);
      }

      async flushNow() {
        if (this.flushing || this.dirty.size === 0) {
          return;
        }
        this.flushing = true;
        try {
          const entries = [];
          for (const index of this.dirty) {
            const chunk = this.cache.get(index);
            if (!chunk) {
              continue;
            }
            entries.push({
              key: this.chunkKey(index),
              value: chunk.slice(0)
            });
          }
          if (entries.length) {
            await idbPutMany(entries, DISK_STORE_NAME);
          }
          this.dirty.clear();
          await idbPut(META_KEY, {
            ...(await idbGet(META_KEY) || {}),
            diskSavedAt: Date.now(),
            diskSize: this.byteLength
          });
        } finally {
          this.flushing = false;
        }
      }

      get(offset, length, callback) {
        this.readRange(offset, length).then(callback).catch(function(error) {
          console.error("Disk read failed:", error);
          callback(new Uint8Array(length));
        });
      }

      async readRange(offset, length) {
        const out = new Uint8Array(length);
        let remaining = length;
        let outPos = 0;
        let ptr = offset;
        while (remaining > 0) {
          const index = Math.floor(ptr / this.chunkSize);
          const chunkOffset = ptr % this.chunkSize;
          const take = Math.min(remaining, this.chunkSize - chunkOffset);
          const chunk = await this.readChunk(index);
          out.set(chunk.subarray(chunkOffset, chunkOffset + take), outPos);
          outPos += take;
          ptr += take;
          remaining -= take;
        }
        return out;
      }

      set(offset, data, callback) {
        this.writeRange(offset, data).then(function() {
          if (callback) {
            callback();
          }
        }).catch(function(error) {
          console.error("Disk write failed:", error);
          if (callback) {
            callback();
          }
        });
      }

      async writeRange(offset, data) {
        let remaining = data.byteLength;
        let inPos = 0;
        let ptr = offset;
        while (remaining > 0) {
          const index = Math.floor(ptr / this.chunkSize);
          const chunkOffset = ptr % this.chunkSize;
          const take = Math.min(remaining, this.chunkSize - chunkOffset);
          const chunk = await this.readChunk(index);
          chunk.set(data.subarray(inPos, inPos + take), chunkOffset);
          this.dirty.add(index);
          inPos += take;
          ptr += take;
          remaining -= take;
        }
        this.scheduleFlush();
      }

      get_state() {
        return [this.byteLength];
      }

      set_state() {}
    }

    function base64ToArrayBuffer(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function getDecodedAssets() {
      if (decodedAssets) {
        return decodedAssets;
      }

      log("Decoding local VM assets into memory...");
      decodedAssets = {
        wasm: base64ToArrayBuffer(window.VM_ASSETS_B64.wasm),
        bios: base64ToArrayBuffer(window.VM_ASSETS_B64.bios),
        vgabios: base64ToArrayBuffer(window.VM_ASSETS_B64.vgabios),
        iso: base64ToArrayBuffer(window.VM_ASSETS_B64.alpine_iso)
      };
      log("Local assets decoded.");
      return decodedAssets;
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function log(text) {
      logEl.textContent += text + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    function serialWrite(ch) {
      serialEl.textContent += ch;
      serialEl.scrollTop = serialEl.scrollHeight;
    }

    function updateButtonsForVmState(running) {
      restartButton.disabled = !running;
      saveButton.disabled = !running;
      exportButton.disabled = false;
    }

    async function loadStoredSnapshot() {
      try {
        const snapshot = await idbGet(STATE_KEY);
        if (snapshot && snapshot instanceof ArrayBuffer && isLikelyV86State(snapshot)) {
          loadedStateForBoot = snapshot;
          loadedStateSource = "stored";
          const meta = await idbGet(META_KEY);
          if (meta && meta.savedAt) {
            log("Found persisted snapshot from " + new Date(meta.savedAt).toLocaleString() + ".");
          } else {
            log("Found persisted snapshot.");
          }
          return;
        }
      } catch (error) {
        log("Warning loading persisted snapshot: " + error.message);
      }
      loadedStateForBoot = null;
      loadedStateSource = null;
    }

    async function saveSnapshot(reason) {
      if (!vm || saveInProgress) {
        return;
      }
      saveInProgress = true;
      try {
        const state = await vm.save_state();
        await idbPut(STATE_KEY, state);
        await idbPut(META_KEY, {
          savedAt: Date.now(),
          size: state.byteLength,
          reason: reason || "manual"
        });
        loadedStateForBoot = state;
        loadedStateSource = "stored";
        log("Saved VM state (" + formatBytes(state.byteLength) + ").");
      } catch (error) {
        log("Failed to save state: " + error.message);
      } finally {
        saveInProgress = false;
      }
    }

    function startAutoSave() {
      stopAutoSave();
      autoSaveTimer = setInterval(function() {
        saveSnapshot("autosave");
      }, AUTO_SAVE_MS);
    }

    function stopAutoSave() {
      if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        autoSaveTimer = null;
      }
    }

    async function clearStoredSnapshot() {
      await idbDelete([STATE_KEY, META_KEY]);
      const meta = await idbGet(DISK_META_KEY);
      if (meta && meta.byteLength) {
        const chunkCount = Math.ceil(meta.byteLength / (meta.chunkSize || DISK_CHUNK_SIZE));
        const keys = [];
        for (let i = 0; i < chunkCount; i += 1) {
          keys.push("chunk:" + i);
        }
        if (keys.length) {
          await idbDelete(keys, DISK_STORE_NAME);
        }
      }
      await idbDelete([DISK_META_KEY]);
      if (persistentDisk) {
        persistentDisk.cache.clear();
        persistentDisk.dirty.clear();
      }
      loadedStateForBoot = null;
      loadedStateSource = null;
    }

    async function exportSnapshot() {
      let state = null;
      if (vm) {
        try {
          state = await vm.save_state();
        } catch (error) {
          log("Live export failed, trying stored snapshot: " + error.message);
        }
      }

      if (!state) {
        state = await idbGet(STATE_KEY);
      }
      if (!state || !(state instanceof ArrayBuffer) || !isLikelyV86State(state)) {
        log("No valid VM state available to export.");
        return;
      }

      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      const blob = new Blob([state], { type: "application/octet-stream" });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement("a");
      anchor.href = url;
      anchor.download = "alpine-vm-state-" + stamp + ".v86state";
      document.body.appendChild(anchor);
      anchor.click();
      anchor.remove();
      URL.revokeObjectURL(url);
      log("Exported VM state (" + formatBytes(state.byteLength) + ").");
    }

    async function handleImportFile(file) {
      if (!file) {
        return;
      }
      const buffer = await file.arrayBuffer();
      if (!isLikelyV86State(buffer)) {
        log("Import rejected: file is not a valid v86 state image.");
        return;
      }
      await idbPut(STATE_KEY, buffer);
      await idbPut(META_KEY, {
        savedAt: Date.now(),
        size: buffer.byteLength,
        reason: "import"
      });
      loadedStateForBoot = buffer;
      loadedStateSource = "imported";
      log("Imported VM state (" + formatBytes(buffer.byteLength) + ").");

      if (vm) {
        log("Restarting VM to apply imported state...");
        await startVm();
      }
    }

    async function startVm() {
      if (typeof V86 === "undefined" || typeof window.VM_ASSETS_B64 === "undefined") {
        setStatus("Failed");
        log("Required local scripts did not load (libv86.js or vm-assets.js).");
        return;
      }

      startButton.disabled = true;
      setStatus("Starting");
      log("Preparing Alpine VM...");
      stopAutoSave();

      if (vm) {
        try {
          await vm.stop();
        } catch (error) {
          log("Warning stopping previous VM: " + error.message);
        }
        vm = null;
      }

      screenEl.replaceChildren();
      serialEl.textContent = "";

      try {
        await loadStoredSnapshot();
        const assets = getDecodedAssets();
        const relayUrl = relayUrlInput.value.trim();
        const networkEnabled = netToggle.checked && relayUrl.length > 0;
        if (!persistentDisk) {
          persistentDisk = new IndexedDbDiskBuffer(DISK_SIZE_BYTES, DISK_CHUNK_SIZE);
        }
        await persistentDisk.load();
        log("Persistent disk ready (" + formatBytes(DISK_SIZE_BYTES) + ").");

        vm = new V86({
          ...CONFIG,
          wasm_fn: function(imports) {
            return WebAssembly.instantiate(assets.wasm, imports).then(function(result) {
              return result.instance.exports;
            });
          },
          bios: { buffer: assets.bios.slice(0) },
          vga_bios: { buffer: assets.vgabios.slice(0) },
          cdrom: { buffer: assets.iso.slice(0) },
          hda: persistentDisk,
          network_relay_url: networkEnabled ? relayUrl : undefined,
          initial_state: loadedStateForBoot || undefined,
          screen_container: screenEl
        });

        vm.add_listener("emulator-ready", function() {
          setStatus("Running");
          updateButtonsForVmState(true);
          if (loadedStateForBoot) {
            log("VM resumed from " + loadedStateSource + " snapshot.");
          } else {
            log("Alpine VM started from bundled ISO.");
          }
          if (networkEnabled) {
            log("Network relay enabled: " + relayUrl);
          } else {
            log("Network relay disabled.");
          }
          startAutoSave();
        });

        vm.add_listener("download-progress", function(e) {
          if (!e || !e.file_name) {
            return;
          }
          const pct = e.total ? Math.floor((e.loaded / e.total) * 100) : 0;
          setStatus("Downloading " + pct + "%");
        });

        vm.add_listener("serial0-output-byte", function(b) {
          serialWrite(String.fromCharCode(b));
        });

        log("Booting VM...");
      } catch (error) {
        setStatus("Failed");
        startButton.disabled = false;
        updateButtonsForVmState(false);
        log("Failed to start VM: " + error.message);
      }
    }

    startButton.addEventListener("click", startVm);
    restartButton.addEventListener("click", async function() {
      setStatus("Restarting");
      log("Restart requested...");
      await saveSnapshot("restart");
      startVm();
    });
    saveButton.addEventListener("click", function() {
      saveSnapshot("manual");
    });
    exportButton.addEventListener("click", function() {
      exportSnapshot();
    });
    importButton.addEventListener("click", function() {
      importFileInput.click();
    });
    importFileInput.addEventListener("change", function(e) {
      const file = e.target.files && e.target.files[0] ? e.target.files[0] : null;
      handleImportFile(file).catch(function(error) {
        log("Import failed: " + error.message);
      });
      importFileInput.value = "";
    });
    clearButton.addEventListener("click", async function() {
      try {
        await clearStoredSnapshot();
        log("Cleared persisted VM snapshot and virtual disk.");
      } catch (error) {
        log("Failed clearing persisted snapshot: " + error.message);
      }
    });
    window.addEventListener("pagehide", function() {
      saveSnapshot("pagehide");
      if (persistentDisk) {
        persistentDisk.flushNow();
      }
    });
    document.addEventListener("visibilitychange", function() {
      if (document.visibilityState === "hidden") {
        saveSnapshot("hidden");
        if (persistentDisk) {
          persistentDisk.flushNow();
        }
      }
    });

    log("Ready. Click Start Alpine VM.");
    log("Persistence: VM state is auto-saved in IndexedDB and restored on next start.");
    log("Disk: a real 1.00 GB virtual hard disk is stored in IndexedDB.");
    log("Import/Export: use .v86state files to move the full machine state.");
    log("Network: toggle relay before boot if you want internet from inside Alpine.");
    updateButtonsForVmState(false);
    exportButton.disabled = false;
  </script>
</body>
</html>
